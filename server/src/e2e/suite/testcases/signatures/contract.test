========================================================================
Basic Function with Multiple Parameters
========================================================================
primitive Int;
primitive String;

struct User {
    name: String;
    age: Int;
}

contract Foo {
    fun baz(user: User, action: String, value: Int) {
        // ...
    }

    init() {
        self.baz(user, "update", <caret>);
    }
}
------------------------------------------------------------------------
value: Int
fun baz(user: User, action: String, value: Int)

========================================================================
Function Overloading
========================================================================
primitive Int;
primitive String;

contract Foo {
    fun add(a: Int, b: Int): Int {
        return a + b;
    }

    fun add(a: String, b: String): String {
        return a + b;
    }

    init() {
        self.add("hello", <caret>);
    }
}
------------------------------------------------------------------------
b: Int
fun add(a: Int, b: Int)

========================================================================
Nested Function Calls
========================================================================
primitive Int;
primitive String;

contract Foo {
    fun multiply(a: Int, b: Int): Int {
        return a * b;
    }

    fun calculate(x: Int, y: Int, z: Int): Int {
        return x + self.multiply(y, z);
    }

    init() {
        self.calculate(10, <caret>);
    }
}
------------------------------------------------------------------------
y: Int
fun calculate(x: Int, y: Int, z: Int)

========================================================================
Nested Function Calls
========================================================================
primitive Int;

contract Foo {
    fun double(x: Int): Int {
        return x * 2;
    }

    fun triple(x: Int): Int {
        return x * 3;
    }

    init() {
        self.double(self.triple(<caret>));
    }
}
------------------------------------------------------------------------
y: Int
fun calculate(x: Int, y: Int, z: Int)

========================================================================
Promt first arg while second is filled
========================================================================
primitive Int;

contract Foo {
    fun add(a: Int, b: Int): Int {
        return a + b;
    }

    init() {
        self.add(<caret>, 2);
    }
}
------------------------------------------------------------------------
a: Int
fun add(a: Int, b: Int)

========================================================================
Set Map (Key)
========================================================================
primitive Int;
extends mutates fun set(self: map<K, V>, key: K, val: V);

contract A {
    init() {
        let fizz: map<Int, Int> = emptyMap();

        fizz.set(<caret>)
    }
}
------------------------------------------------------------------------
key: K
fun set(self: map<K, V>, key: K, val: V)

========================================================================
Set Map (Value)
========================================================================
primitive Int;
extends mutates fun set(self: map<K, V>, key: K, val: V);

contract A {
    init() {
        let fizz: map<Int, Int> = emptyMap();

        fizz.set(42, <caret>)
    }
}
------------------------------------------------------------------------
val: V
fun set(self: map<K, V>, key: K, val: V)

========================================================================
Get value from Map
========================================================================
primitive Int;
extends fun get(self: map<K, V>, key: K): V?;
contract A {
    init() {
        let fizz: map<Int, Int> = emptyMap();

        fizz.get(<caret>);
    }
}
------------------------------------------------------------------------
key: K
fun get(self: map<K, V>, key: K)

========================================================================
Replace value map by key (caret on key)
========================================================================
primitive Int;
extends mutates fun replace(self: map<K, V>, key: K, val: V): Bool;
contract A {
    init() {
        let fizz: map<Int, Int> = emptyMap();

        fizz.replace(<caret>)
    }
}
------------------------------------------------------------------------
key: K
fun replace(self: map<K, V>, key: K, val: V)

========================================================================
Replace value map by key (caret on value)
========================================================================
primitive Int;
extends mutates fun replace(self: map<K, V>, key: K, val: V): Bool;
contract A {
    init() {
        let fizz: map<Int, Int> = emptyMap();

        fizz.replace(42, <caret>)
    }
}
------------------------------------------------------------------------
val: V
fun replace(self: map<K, V>, key: K, val: V)

========================================================================
External Contract Initialization
========================================================================
primitive Int;

contract ContractA {
    init(a: Int) {

    }
}

contract ContractB {
    init() {
        initOf ContractA(<caret>)
    }
}
------------------------------------------------------------------------
a: Int
init(a: Int)

========================================================================
Global function with Map
========================================================================
primitive Int;
primitive String;

struct Key {
    id: Int;
    name: String;
}

get fun globalFunc(map: Map<Key, Int>) {
    // ...
}

contract Foo {
    init() {
        let key = Key { id: 1, name: "Test" };
        let map = emptyMap();
        globalFunc(<caret>)
    }
}
------------------------------------------------------------------------
map: Map
fun globalFunc(map: Map)

========================================================================
Global function with String
========================================================================
primitive Int;

fun globalFunc(input: Int): Int {
    return input;
}

contract A {
    init() {
        globalFunc(<caret>)
    }
}
------------------------------------------------------------------------
input: Int
fun globalFunc(input: Int)

========================================================================
Struct Key
========================================================================
primitive Int;
primitive String;

struct Person {
    age: Int;
    name: String;
}

contract Foo {
    init() {
        const userA = Person{age:<caret>,}
    }
}
------------------------------------------------------------------------
age: Int
Person{ age: Int, name: String }
